const express = require('express');
const crypto = require('crypto');

class PostbackHandler {
  constructor(bot, database, logger) {
    this.bot = bot;
    this.db = database;
    this.logger = logger;
    this.app = express();
    this.setupMiddleware();
    this.setupRoutes();
  }

  setupMiddleware() {
    // Middleware –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON –∏ URL-encoded –¥–∞–Ω–Ω—ã—Ö
    this.app.use(express.json());
    this.app.use(express.urlencoded({ extended: true }));

    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –≤—Ö–æ–¥—è—â–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
    this.app.use((req, res, next) => {
      this.logger.info(`Postback received: ${req.method} ${req.url}`, {
        headers: req.headers,
        query: req.query,
        body: req.body,
        ip: req.ip
      });
      next();
    });
  }

  setupRoutes() {
    // Health check endpoint
    this.app.get('/health', (req, res) => {
      res.json({ status: 'ok', timestamp: new Date().toISOString() });
    });

    // PocketOption –ø–æ—Å—Ç–±—ç–∫–∏
    this.app.get('/postback/pocketoption', (req, res) => this.handlePocketOptionPostback(req, res));
    this.app.post('/postback/pocketoption', (req, res) => this.handlePocketOptionPostback(req, res));

    // TopLink –ø–æ—Å—Ç–±—ç–∫–∏ (–µ—Å–ª–∏ –ø–æ–Ω–∞–¥–æ–±—è—Ç—Å—è)
    this.app.get('/postback/toplink', (req, res) => this.handleTopLinkPostback(req, res));
    this.app.post('/postback/toplink', (req, res) => this.handleTopLinkPostback(req, res));

    // –û–±—â–∏–π endpoint –¥–ª—è –¥—Ä—É–≥–∏—Ö –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤
    this.app.get('/postback/:partner', (req, res) => this.handleGenericPostback(req, res));
    this.app.post('/postback/:partner', (req, res) => this.handleGenericPostback(req, res));

    // 404 –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
    this.app.use('*', (req, res) => {
      this.logger.warn(`404 Not Found: ${req.method} ${req.originalUrl}`);
      res.status(404).json({ error: 'Endpoint not found' });
    });

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
    this.app.use((error, req, res, next) => {
      this.logger.error('Express error handler', error);
      res.status(500).json({ error: 'Internal server error' });
    });
  }

  async handlePocketOptionPostback(req, res) {
    try {
      const data = { ...req.query, ...req.body };

      this.logger.info('PocketOption postback received', data);

      // –í–∞–ª–∏–¥–∞—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
      const requiredParams = ['clickid'];
      const missingParams = requiredParams.filter(param => !data[param]);

      if (missingParams.length > 0) {
        this.logger.warn(`Missing required parameters: ${missingParams.join(', ')}`, data);
        return res.status(400).json({
          error: 'Missing required parameters',
          missing: missingParams
        });
      }

      // –í–∞–ª–∏–¥–∞—Ü–∏—è —Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ (–µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω)
      if (process.env.POCKETOPTION_SECRET_KEY) {
        if (!this.validatePocketOptionSignature(data)) {
          this.logger.warn('Invalid PocketOption signature', data);
          return res.status(401).json({ error: 'Invalid signature' });
        }
      }

      // –ù–∞–π—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ clickid
      const user = await this.findUserByClickId(data.clickid);
      if (!user) {
        this.logger.warn(`User not found for clickid: ${data.clickid}`);
        return res.status(404).json({ error: 'User not found' });
      }

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Å–æ–±—ã—Ç–∏–π
      let eventType = 'unknown';
      if (data.reg) {
        eventType = 'registration';
        await this.handleRegistration(user, data);
      } else if (data.ftd) {
        eventType = 'first_deposit';
        await this.handleFirstDeposit(user, data);
      } else if (data.dep) {
        eventType = 'deposit';
        await this.handleDeposit(user, data);
      }

      // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è
      await this.db.logUserAction(user.telegram_id, `postback_${eventType}`, {
        partner: 'pocketoption',
        clickid: data.clickid,
        playerid: data.playerid,
        sum: data.sum,
        eventData: data
      });

      this.logger.info(`PocketOption ${eventType} processed for user ${user.telegram_id}`, data);

      res.json({
        status: 'success',
        event: eventType,
        user_id: user.telegram_id,
        processed_at: new Date().toISOString()
      });

    } catch (error) {
      this.logger.error('Error processing PocketOption postback', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  async handleTopLinkPostback(req, res) {
    try {
      const data = { ...req.query, ...req.body };

      this.logger.info('TopLink postback received', data);

      // –ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –¥–ª—è TopLink –ø–æ—Å—Ç–±—ç–∫–æ–≤
      // –ü–æ–∫–∞ —á—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–∞–≥–ª—É—à–∫—É

      res.json({
        status: 'success',
        message: 'TopLink postback received but not implemented yet'
      });

    } catch (error) {
      this.logger.error('Error processing TopLink postback', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  async handleGenericPostback(req, res) {
    try {
      const partner = req.params.partner;
      const data = { ...req.query, ...req.body };

      this.logger.info(`Generic postback received from ${partner}`, data);

      // –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ—Å—Ç–±—ç–∫–æ–≤ –æ—Ç –¥—Ä—É–≥–∏—Ö –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤

      res.json({
        status: 'success',
        partner,
        message: 'Generic postback received',
        data
      });

    } catch (error) {
      this.logger.error('Error processing generic postback', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  validatePocketOptionSignature(data) {
    try {
      const secretKey = process.env.POCKETOPTION_SECRET_KEY;
      if (!secretKey) return true; // –ï—Å–ª–∏ —Å–µ–∫—Ä–µ—Ç –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –≤–∞–ª–∏–¥–∞—Ü–∏—é

      // –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä–æ–∫—É –¥–ª—è –ø–æ–¥–ø–∏—Å–∏ –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
      const params = Object.keys(data)
        .filter(key => key !== 'signature' && key !== 'hash')
        .sort()
        .map(key => `${key}=${data[key]}`)
        .join('&');

      const expectedSignature = crypto
        .createHmac('sha256', secretKey)
        .update(params)
        .digest('hex');

      return data.signature === expectedSignature || data.hash === expectedSignature;
    } catch (error) {
      this.logger.error('Error validating signature', error);
      return false;
    }
  }

  async findUserByClickId(clickId) {
    try {
      // –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ clickid
      // clickid –æ–±—ã—á–Ω–æ —Å–æ–¥–µ—Ä–∂–∏—Ç telegram_id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

      // –ï—Å–ª–∏ clickid - —ç—Ç–æ –ø—Ä—è–º–æ telegram_id
      const telegramId = parseInt(clickId);
      if (!isNaN(telegramId)) {
        const user = await this.db.getUserByTelegramId(telegramId);
        if (user) return user;
      }

      // –ú–æ–∂–Ω–æ —Ç–∞–∫–∂–µ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å clickid –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ–ª–µ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å—Å—ã–ª–æ–∫
      // –ü–æ–∫–∞ —á—Ç–æ –∏—â–µ–º –ø–æ telegram_id
      this.logger.warn(`Could not parse telegram_id from clickid: ${clickId}`);
      return null;

    } catch (error) {
      this.logger.error('Error finding user by clickid', error);
      return null;
    }
  }

  async handleRegistration(user, data) {
    try {
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      await this.db.updateUser(user.telegram_id, {
        partner_status: 'registered',
        partner_id: data.playerid,
        registration_date: new Date().toISOString()
      });

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
      const lang = await this.db.getUserLanguage(user.telegram_id);
      const message = lang === 'en'
        ? 'üéâ Congratulations! Your registration has been confirmed. You can now start trading!'
        : 'üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í–∞—à–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞. –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –Ω–∞—á–∞—Ç—å —Ç–æ—Ä–≥–æ–≤–∞—Ç—å!';

      await this.bot.sendMessage(user.telegram_id, message);

      this.logger.info(`Registration confirmed for user ${user.telegram_id}`);

    } catch (error) {
      this.logger.error('Error handling registration', error);
    }
  }

  async handleFirstDeposit(user, data) {
    try {
      const depositAmount = parseFloat(data.sum) || 0;

      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      await this.db.updateUser(user.telegram_id, {
        partner_status: 'deposited',
        first_deposit_amount: depositAmount,
        first_deposit_date: new Date().toISOString(),
        vip_status: true // –ü—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º VIP –¥–æ—Å—Ç—É–ø –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ –¥–µ–ø–æ–∑–∏—Ç–∞
      });

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ VIP –¥–æ—Å—Ç—É–ø–µ
      await this.grantVipAccess(user, depositAmount);

      this.logger.info(`First deposit confirmed for user ${user.telegram_id}, amount: ${depositAmount}`);

    } catch (error) {
      this.logger.error('Error handling first deposit', error);
    }
  }

  async handleDeposit(user, data) {
    try {
      const depositAmount = parseFloat(data.sum) || 0;

      // –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–≤—Ç–æ—Ä–Ω—ã–π –¥–µ–ø–æ–∑–∏—Ç
      await this.db.logUserAction(user.telegram_id, 'repeat_deposit', {
        amount: depositAmount,
        playerid: data.playerid
      });

      // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –ª–æ–≥–∏–∫—É –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –¥–µ–ø–æ–∑–∏—Ç–æ–≤

      this.logger.info(`Repeat deposit confirmed for user ${user.telegram_id}, amount: ${depositAmount}`);

    } catch (error) {
      this.logger.error('Error handling deposit', error);
    }
  }

  async grantVipAccess(user, depositAmount) {
    try {
      const lang = await this.db.getUserLanguage(user.telegram_id);

      let message;
      if (lang === 'en') {
        message = `üéâ *VIP ACCESS UNLOCKED!*\n\n` +
                 `Your deposit of $${depositAmount} has been confirmed!\n\n` +
                 `You now have access to:\n` +
                 `üîî Private trading signals\n` +
                 `üìà Exclusive market analysis\n` +
                 `üíº Personal trading consultation\n\n` +
                 `Welcome to the VIP club! üåü`;
      } else {
        message = `üéâ *VIP –î–û–°–¢–£–ü –û–¢–ö–†–´–¢!*\n\n` +
                 `–í–∞—à –¥–µ–ø–æ–∑–∏—Ç –≤ —Ä–∞–∑–º–µ—Ä–µ $${depositAmount} –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω!\n\n` +
                 `–¢–µ–ø–µ—Ä—å —É –≤–∞—Å –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø –∫:\n` +
                 `üîî –ü—Ä–∏–≤–∞—Ç–Ω—ã–º —Ç–æ—Ä–≥–æ–≤—ã–º —Å–∏–≥–Ω–∞–ª–∞–º\n` +
                 `üìà –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω–æ–π –∞–Ω–∞–ª–∏—Ç–∏–∫–µ —Ä—ã–Ω–∫–∞\n` +
                 `üíº –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–º —Ç–æ—Ä–≥–æ–≤—ã–º –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è–º\n\n` +
                 `–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ VIP –∫–ª—É–±! üåü`;
      }

      await this.bot.sendMessage(user.telegram_id, message, {
        parse_mode: 'Markdown'
      });

      // –ï—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω VIP –∫–∞–Ω–∞–ª, –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      if (process.env.VIP_CHANNEL_ID) {
        try {
          // –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–≥–ª–∞—Å–∏—Ç–µ–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É
          const inviteLink = await this.bot.createChatInviteLink(process.env.VIP_CHANNEL_ID, {
            member_limit: 1,
            expire_date: Math.floor(Date.now() / 1000) + 3600 // –ò—Å—Ç–µ–∫–∞–µ—Ç —á–µ—Ä–µ–∑ —á–∞—Å
          });

          const inviteMessage = lang === 'en'
            ? `üîó Here's your private link to the VIP channel:\n${inviteLink.invite_link}\n\n*This link will expire in 1 hour.*`
            : `üîó –í–æ—Ç –≤–∞—à–∞ –ø—Ä–∏–≤–∞—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ VIP –∫–∞–Ω–∞–ª:\n${inviteLink.invite_link}\n\n*–°—Å—ã–ª–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç —á–µ—Ä–µ–∑ 1 —á–∞—Å.*`;

          await this.bot.sendMessage(user.telegram_id, inviteMessage, {
            parse_mode: 'Markdown'
          });

        } catch (error) {
          this.logger.error('Error creating VIP channel invite', error);
        }
      }

    } catch (error) {
      this.logger.error('Error granting VIP access', error);
    }
  }

  startServer(port = 3000) {
    return new Promise((resolve, reject) => {
      this.server = this.app.listen(port, (error) => {
        if (error) {
          this.logger.error('Failed to start postback server', error);
          reject(error);
        } else {
          this.logger.info(`Postback server started on port ${port}`);
          console.log(`üåê Postback server running on port ${port}`);
          resolve();
        }
      });
    });
  }

  stopServer() {
    return new Promise((resolve) => {
      if (this.server) {
        this.server.close(() => {
          this.logger.info('Postback server stopped');
          resolve();
        });
      } else {
        resolve();
      }
    });
  }
}

module.exports = PostbackHandler;